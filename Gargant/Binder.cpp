#include "stdafx.h"
#pragma once

//Takes the Word/Part of Speech pair generated by the binder and assigns a game object to each one.
std::string Binder::bind(std::vector<std::pair<std::string, std::string>> parsed_list) {
	std::vector<Token*> token_list;
	Token* tok = nullptr;
	std::vector<std::pair<std::string, std::string>> object_data;

	for (auto el : parsed_list) {
		if (el.second == "A") {
			object_data.push_back(el);
		}
		else {
			if (el.second == "t" || el.second == "i") {
				tok = (get_Action(el.first));
			}
			else if (el.second == "N") {
				object_data.push_back(el);
				std::vector<Object*> filtered_list = filter_object_list(object_data);
				if (filtered_list.size() > 1)
					return "Which " + el.first + "?";
				else tok = filtered_list[0];
				object_data = {};
			}
			else if (el.second == "R") {
				tok = get_Room(el.first);
			}
			else if (el.second == "d") {
				tok = get_Door(el.first);
			}
			token_list.push_back(tok);
			tok = nullptr;
		}
	}
	try {
		std::string bounded = call(token_list);
		return bounded;
	}
	catch (std::runtime_error err) {
		return err.what();
	}
}
//Separates the token list into Actions and things to be acted on
std::string Binder::call(std::vector<Token*> args) {
	auto iter = args.begin();
	Action *act = static_cast<Action *>(*iter);
	std::vector<Object*> objects;
	iter++;
	for (auto beg = iter; beg != args.end(); beg++) {
		if ((*beg)->get_classifier() == "object") {
			Object *obj = static_cast<Object *>(*beg);
			objects.push_back(obj);
		}
	}
	if (args.size() == 1) return translate(*act);
	else if (objects.size() == 1) {
		auto obj_iter = *objects.begin();
		return translate(*act, obj_iter);
	}
	else if (objects.size() == 2) {
		auto obj_iter = objects.begin();
		auto *obj = *obj_iter++;
		auto obj2 = *obj_iter;
		return translate(*act, obj, obj2);
	}
	else if ((*iter)->get_classifier() == "room") {
		Room *room = static_cast<Room *>(*iter);
		if (args.size() == 2) {
			return translate(*act, room);
		}
	}
	else if ((*iter)->get_classifier() == "door") {
		Door *door = static_cast<Door *>(*iter);
		if (args.size() - 1 == 1) {
			return translate(*act, door);
		}
	}
	return "";
}
//Resolves the binding into one of the Action categories
std::string Binder::translate(Action& act, Object* obj) {
	switch (act.index) {
	case Action::PICK_UP_INDEX: return pick_up(obj);
		break;
	case Action::PUT_DOWN_INDEX: return put_down(obj);
		break;
	case Action::EXAMINE_INDEX: return examine(obj);
		break;
	}
}

std::string Binder::translate(Action& act, Object* obj, Object* obj2) {
	switch (act.index) {
	case Action::USE_INDEX:
		return use(obj, obj2);
		break;
	}
}
std::string Binder::translate(Action& act, Room* room) {
	switch (act.index) {
	case Action::EXAMINE_INDEX: return examine(room);
		break;
	case Action::MOVE_INDEX: return move(room);
		break;
	case Action::PICK_UP_INDEX: return pick_up(room);
		break;
	case Action::PUT_DOWN_INDEX: return put_down(room);
		break;
	}
}

std::string Binder::translate(Action& act, Door* door) {
	switch (act.index) {
	case Action::EXAMINE_INDEX: return examine(door);
		break;
	case Action::MOVE_INDEX: return move(door);
		break;
	case Action::USE_INDEX: return move(door);
		break;
	case Action::PICK_UP_INDEX: return pick_up(door);
		break;
	case Action::PUT_DOWN_INDEX: return put_down(door);
		break;
	}
}

std::string Binder::translate(Action& act) {
	switch (act.index) {
	case Action::EXAMINE_INDEX:
		//		examine(std::cout);
		return "";
		break;
	default:
		return "Heeeeey";
	}
}
//Outputs the Description portion of an object's data Script.
//Scripts are updated after every parse
std::string Binder::examine() {
	return examine(state->current);
}

std::string Binder::examine(Room* room) {
	if (room->get_name() =="") return "Looks like nothing to me";
	return room->describe();
}
std::string Binder::examine(Object* obj) {
	if (obj ->get_name() == "") return "Looks like nothing to me";
	return obj->describe();
}
std::string Binder::examine(Door* door) {
	if (door->get_name() == "") return "Looks like nothing to me";
	return door->describe();
}

//Moves the player to a new room by changing the location that *current points to
std::string Binder::move(Room* destination) {
	if (state->current == destination) return "You're already in " + destination->getname();
	if (destination->get_name() == "") return "You can't go there";
	Door* door = nullptr;
	for (auto &el : state->current->doors) {
		if (destination == el.destination()) door = &el;
	}
	return move(door);
}
//This... is a janky work around for usign doors.
std::string Binder::move(Door* door) {
	if (door->get_name()=="") return "You can't go there";
	if (state->is_locked(*door)) return "The door is locked";
	state->current = door->destination();
	return ((door->data.move_txt == "")? "You have moved to " + door->destination()->get_name() : door->data.move_txt) + "\n";
}
//Moves an item from the room the player is currently in to inventory so long as can_carry is true
std::string Binder::pick_up(Object* obj) {
	if (obj->get_name() == "") return "I don't see anything like that around";
	else {
		Object temp = *obj;
		if (!obj->can_carry) {
			return (obj->data.pick_up_error == "")? "You can't pick that up." : obj->data.pick_up_error;
		}
		else if (state->transfer(state->inventory, state->current->room_objects, *obj)) {
			return "You have picked the " + temp.getname() + " up";
		}
		else return "You already have the " + temp.getname();
	}
}

std::string Binder::pick_up(Door* door) {
	return !(door->data.pick_up_error == "") ? door->data.pick_up_error : "You can't pick that up.";
}

std::string Binder::pick_up(Room* room) {
	return (!(room->data.pick_up_error == "") && room == state->current)? room->data.pick_up_error : "You don't have room for that.";
}

//Moves an item from inventory to whatever room the player is currently in
std::string Binder::put_down(Object* obj) {
	if (obj->get_name() == "") return "I don't have anything like that";
	else {
		Object temp = *obj;
		if (state->transfer(state->current->room_objects, state->inventory, *obj))
			return "You have put down the " + temp.getname();
		else return "You are not carrying the " + temp.getname();
	}
}
std::string Binder::put_down(Door* door) {
	return (door->data.put_down_error == "") ? "You can't pick that up." : door->data.put_down_error;
}

std::string Binder::put_down(Room* room) {
	return (room->data.put_down_error == "") ? "You can't pick that up." : room->data.put_down_error;
}

//Activates an item if it can be unarily used
std::string Binder::use(Object* use) {
	return "advfawdvqefv";
}

//Checks the item combination against all of the item puzsles in the game. Item puzzles generate a flag which is moved into flags_obtained
std::string Binder::use(Object* use, Object* used_on) {
	if (use->get_name() == "" || used_on->get_name() == "") return "Well I don't know about that...";
	if (std::find(state->inventory.begin(), state->inventory.end(), *use) == state->inventory.end()) return "You aren't carrying the " + use->get_name() + ".";
	if (std::find(state->current->room_objects.begin(), state->current->room_objects.end(), *used_on) != state->current->room_objects.end() && used_on->can_carry) return "You aren't carrying the " + used_on->get_name() + ".";
	for (auto& puzzle : state->puzzles) {
		if (puzzle.solve(*state, *use, *used_on)) {
			state->flags_obtained.push_back(puzzle.get_flag());
			//return "You used " + use->getname() + " on " + used_on->getname();
			return use->data.use_txt;
		}
	}
	//return "You can't use " + use->getname() + " on " + used_on->getname();
	return "//ERROR::"+Scripting_Engine::format_name(used_on->get_name()) + "//" + " " + use->data.use_error;
}
//Opens a container
std::string Binder::use(Container* use) {
	if (use->get_name() == "") return "I don't think you can open that.";
	else {
		use->toggle();
		return use->data.use_txt;
	}
}
//pools all of the objects from inventory and current room
std::vector<Object*> Binder::pool_objects() {
	std::vector<Object*> object_list;
	for (auto &el : state->inventory) {
		object_list.push_back(&el);
	}
	for (auto &el : state->current->room_objects) {
		object_list.push_back(&el);
	}
	return object_list;
}

//Checks user input against word list and returns a pointer to it
Action* Binder::get_Action(std::string name) {
	for (auto &el : state->action_list) {
		if (el.get_name() == name) {
			return &el;
		}
	}
	return &NULL_ACTION;
}

//Gets door
Door* Binder::get_Door(std::string name) {
	for (auto &el : state->current->doors) {
		if (el.get_name() == name) {
			return &el;
		}
	}
	return &NULL_DOOR;
}

//Checks input name against word list, returns a match if found, else moves to filtering
std::vector<Object*> Binder::filter_object_list(std::vector<std::pair<std::string, std::string>> object_data) {
	std::vector<Object*> object_list = pool_objects();
	std::string name;
	for (auto el : object_data) {
		if (name != "")name += " ";
		name += el.first;
	}
	for (auto el : object_list) {
		if (el->get_name() == name) return{ el };
	}
	return filter_object_list(object_data, object_list);
}
//Filters list of available objects using supplied adjectives. If unable to narrow selections down to 1, then returns the Null Object. This should probably be a separate method in retrospect.
std::vector<Object*> Binder::filter_object_list(std::vector<std::pair<std::string, std::string>> object_data, std::vector<Object*> object_list) {
	std::vector<Object*> filtered_list;
	auto iter = object_data.begin();
	if (iter == object_data.end()) return{ &NULL_OBJECT };
	else if (iter->second == "A") {
		for (auto el : object_list) {
			if (std::find(el->attributes.begin(), el->attributes.end(), iter->first) != el->attributes.end()) {
				filtered_list.push_back(el);
			}
		}
		return filter_object_list(std::vector<std::pair<std::string, std::string>>(++iter, object_data.end()), filtered_list);
	}
	else if (iter->second == "N") {
		for (auto el : object_list) {
			if (el->get_type() == iter->first) {
				filtered_list.push_back(el);
			}
		}
		if (filtered_list.size() > 0) {
			return filtered_list;
		}
		else {
			return { &NULL_OBJECT };
		}
	}
	else return{ &NULL_OBJECT };
}
//Checks user input against potential destinations the player can go to by checking where each door leads.
Room* Binder::get_Room(std::string name) {
	if (name == state->current->getname()) return state->current;
	for (auto &el : state->current->doors) {
		if (el.destination()->getname() == name) {
			return el.destination();
		}
	}
	return &NULL_ROOM;
}